#!/usr/bin/env python3
#
# ingest the TXT file generated by "mtr" and read it as records

import sys
if sys.version < "3.4":
    raise RuntimeError("validator requires Pyton 3.4 or above")
import os,datetime,re
import sqlite3

import mtr_tools

schema = \
"""
PRAGMA cache_size = 200000;
CREATE TABLE IF NOT EXISTS files (id INTEGER PRIMARY KEY,
                                  timet INTEGER NOT NULL,
                                  hop INTEGER NOT NULL,
                                  hostname VARCHAR,
                                  ipaddr VARCHAR,
                                  usec INTEGER);
CREATE INDEX IF NOT EXISTS files_time ON files(timet,hop);
CREATE INDEX IF NOT EXISTS files_hop ON files(hop);
"""

def create_schema(conn):
    # If the schema doesn't exist, create it
    c = conn.cursor()
    for line in schema.split(";"):
        print(line,end="")
        c.execute(line)

def mtr_records(infile):
    """Return a generator of MtrRecords"""
    with open(args.infile,"rU") as f:
        for line in f:
            m = mtr_tools.MtrRecord(line)
            if hasattr(m,'timet'):
                yield m
                
if __name__=="__main__":
    from collections import defaultdict
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--infile",help="input file",default="mtr.www.comcast.com.csv")
    parser.add_argument("--writeSQL",help="Write to an SQLite3 database")

    args = parser.parse_args()

    if args.writeSQL:
        conn = sqlite3.connect(args.writeSQL)
        create_schema(conn)
        c = conn.cursor()
        c.execute("begin transaction;")
        for r in mtr_records(args.infile):
            c.execute("insert into files (timet,hop,hostname,ipaddr,usec) values (?,?,?,?,?)",
                      (r.timet,r.hop,r.hostname,r.ipaddr,r.usec))
        c.execute("commit;")
        exit(1)
        

    first_time = None
    gaps = []
    hops = defaultdict(list)
    for r in mtr_records(args.infile):
        if not first_time:
            first_time = r.timet
            last_time = r.timet
        if last_time != r.timet:
            gaps.append(r.timet-last_time)
        hops[r.hop].append(r.usec)
        last_time = r.timet
    import statistics
    print(f"First time: {datetime.datetime.fromtimestamp(first_time).isoformat()}")
    print(f"Last time: {datetime.datetime.fromtimestamp(last_time).isoformat()}")
    print(f"gaps: {len(gaps)} mean:{statistics.mean(gaps)} stdev:{statistics.stdev(gaps)}")
    for i in sorted(hops.keys()):
        print(f"Hop {i:3}   {len(hops[i]):6} mean:{statistics.mean(hops[i]):9.0f}  stdev:{statistics.stdev(hops[i]):9.0f}")

